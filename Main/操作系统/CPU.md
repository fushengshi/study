# CPU

![image-20240510224355864](https://gitee.com/fushengshi/image/raw/master/image-20240510224355864.png)

CPU 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类。

- 通用寄存器

  用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。

- 程序计数器（PC 寄存器，Program Counter Register）

  用来存储 CPU 要执行下一条指令所在的内存地址（注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址）。

  一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。

  > JVM 中的程序计数器是对物理 PC 寄存器的一种**抽象模拟**。当执行 Java 方法时，这个抽象的 PC 寄存器存的是 Java 字节码的地址。

- 指令寄存器

  用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。



## CPU 缓存一致性

### CPU Cache

CPU Cache 也称高速缓存。

CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。

>  CPU Cache 缓存的是内存数据，用于解决 CPU 处理速度和内存访问速度不匹配的问题。
>
>  内存缓存的是磁盘数据，用于解决内存访问速度和磁盘访问速度不匹配的问题。



### 缓存一致性

- 写穿（Write Through）

  把数据同时写入内存和 Cache 中。

  - 如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面。
  - 如果数据没有在 Cache 里面，就直接把数据更新到内存里面。

- 写回（Write Back）

  写直达由于每次写操作都会把数据写回到内存，而导致影响性能，为了减少数据写回内存的频率，就出现了写回的方法。

  对于已经缓存在 Cache 的数据的写入，只需要更新其数据就可以，不用写入到内存，只有在需要把缓存里面的脏数据交换出去的时候，才把数据同步到内存里。

  - 如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（dirty），这个脏标记代表 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，此时不用把数据写到内存里。
  - 如果当发生写操作时，数据所对应的 Cache Block 里存放的是别的内存地址的数据，要检查这个 Cache Block 里的数据有没有被标记为脏的：
    - 如果标记为脏，要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后把它标记为脏。
    - 如果没有标记为脏，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，最后把它标记为脏。



### 多核缓存一致性

要实现事务串行化，要做到两点：

- CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心。
- 要引入锁的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了锁，才能进行对应的数据更新。

#### 总线嗅探

当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是总线嗅探（Bus Snooping）。

#### MESI 协议

MESI 协议，是已修改、独占、共享、已失效这四个状态的英文缩写的组合。

整个 MSI 状态的变更是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。

对于在已修改或者独占状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心。



## CPU 调度

在 Linux 里面，实现了一个基于 CFS 的调度算法，也就是完全公平调度（Completely Fair Scheduling）。

这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，没有被运行的任务 vruntime 是不会变化的。

### CPU 运行队列

一个系统通常都会运行着很多任务，多任务的数量基本都是远超 CPU 核心数量，因此这时候就需要**排队**。

每个 CPU 都有自己的运行队列（Run Queue，rq），用于描述在此 CPU 上所运行的所有进程。

- Deadline 运行队列 dl_rq

- 实时任务运行队列 rt_rq

- CFS 运行队列 cfs_rq

  cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点就是下次会被调度的任务。

<img src="https://gitee.com/fushengshi/image/raw/master/image-20240504102234421.png" alt="image-20240504102234421" style="zoom: 67%;" />



这几种调度类是有优先级的，优先级如下：Deadline > Realtime > Fair， Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，先从 dl_rq 里选择任务，然后从 rt_rq 里选择任务，最后从 cfs_rq 里选择任务。因此实时任务总是会比普通任务优先被执行。



## CPU 上下文切换

CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。

CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。



## 地址映射

CPU 通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果 CPU 没有 MMU（Memory Management Unit，内存管理单元），或者有 MMU 但没有启用，CPU 核在取指令或访问内存时发出的地址将直接传到 CPU 芯片的外部地址引脚上，直接被内存芯片（物理内存）接收，这称为物理地址（Physical Address，PA）。

CPU 启用了 MMU，CPU 核发出的地址将被 MMU 截获，从 CPU 到 MMU 的地址称为虚拟地址（Virtual Address，VA），MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址。

![image-20240721002546200](https://gitee.com/fushengshi/image/raw/master/image-20240721002546200.png)

虚拟地址必须和物理地址建立对应的关系，才可以正确的进行地址转换。记录对应关系最简单的办法就是把对应关系记录在一张表中。为了让翻译速度足够地快，这个表必须加载在内存中。Linux采用了分页（paging）的方式来记录对应关系。

![image-20240902200130283](https://gitee.com/fushengshi/image/raw/master/image-20240902200130283.png)





