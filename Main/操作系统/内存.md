# 内存

操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，不同的进程运行的时候写入的是不同的物理地址。

- 程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）。
- 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系转换变成物理地址，然后再通过物理地址访问内存。

> 详见 CPU。

虚拟内存作用：

- 虚拟内存可以使进程运行内存超过物理内存大小

  因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于没有被经常使用到的内存，可以换出到物理内存之外，比如硬盘上的 Swap 区域。

- 解决多进程之间地址冲突

  由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。

- 更好的安全性

  页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。



## 内存布局

### 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

不足之处：

- 内存碎片

  每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部内存碎片的问题。

- 内存交换的效率低

  如果内存交换的时候，交换的是一个占内存空间很大的程序。

### 内存分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间称为页（Page）。在 Linux 下，每一页的大小为 `4KB`。

针对分段的不足之处：

- 采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。

  但是因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，最少只能分配一个页，所以页内会出现内存浪费，针对内存分页机制会有内部内存碎片的现象。

- 如果内存空间不够，操作系统会把其他正在运行的进程中的 最近没被使用 的内存页面给释放掉，暂时写在硬盘上（Swap机制）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，内存交换的效率就相对比较高。

分页的方式不需要一次性都把程序加载到物理内存中，可以在虚拟内存和物理内存的页映射之后，不把页加载到物理内存，而是在程序运行用到对应虚拟内存页里面的指令和数据时，再加载到物理内存。

内存地址转换步骤：

- 把虚拟内存地址，切分成页号和偏移量。
- 根据页号，从页表里面，查询对应的物理页号。
- 物理页号加上偏移量，得到了物理内存地址。

#### 多级页表

因为操作系统是可以同时运行非常多的进程的，页表空间会非常大，对此采用多级页表（Multi-Level Page Table）的解决方案。

如果某个一级页表的页表项没有被用到，也不需要创建这个页表项对应的二级页表，可以在需要时才创建二级页表。

> 利用局部性原理。

#### TLB

多级页表虽然解决了空间上的问题，但虚拟地址到物理地址的转换步骤增加，降低了地址转换的速度，增加时间上的开销。

CPU 芯片中加入了一个专门存放程序最常访问的页表项的缓存 TLB（Translation Lookaside Buffer），通常称为页表缓存、转址旁路缓存、快表等，存储最常访问的几个页表项。

> 利用局部性原理。



### Linux 内存布局

Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。

![image-20240504105817625](https://gitee.com/fushengshi/image/raw/master/image-20240504105817625.png)

- 内核空间

  内核空间（Kernal Space）只有内核程序可以访问。

  虽然每个进程都各自有独立的虚拟内存，但是**每个虚拟内存中的内核地址，关联的都是相同的物理内存**。

- 用户空间

  用户空间（User Space）这部分内存专门给应用程序使用。

  用户空间内存，从低到高分别是 6 种不同的内存段：

  - 代码段，包括二进制可执行代码。

  - 数据段，包括已初始化的静态常量和全局变量。

  - BSS 段，包括未初始化的静态变量和全局变量。

  - 堆段，包括动态分配的内存，从低地址开始向上增长。

  - 文件映射段，包括动态库、共享内存等，从低地址开始向上增长。

    进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。调用 `mmap` 映射出来的一段虚拟内存空间也保存在这个区域。

  - 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小。



## 内存分配

### malloc 分配内存

malloc 并不是系统调用，而是 C 库里的函数，用于动态分配内存，**malloc 分配的是虚拟内存**。

malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

- 通过 `brk()` 系统调用从堆分配内存

  通过 `brk()` 函数将堆顶指针向高地址移动，获得新的内存空间。如果用户分配的内存小于 128 KB，则通过 `brk()` 申请内存。

  `free` 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用。

- 通过 `mmap()` 系统调用在文件映射区域分配内存

  通过 `mmap()` 系统调用中私有匿名映射的方式，在文件映射区分配一块内存。如果用户分配的内存大于 128 KB，则通过 `mmap()` 申请内存。

  `free` 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。

  > 向操作系统申请内存要通过系统调用，执行系统调用要进行运行态的切换，影响性能。
  >
  > 申请内存的操作应该避免频繁的系统调用，如果都用 `mmap` 来分配内存，每次都要执行系统调用。



## 内存回收

主要有两类内存可以被回收，回收方式也不同。

- 文件页（File-backed Page）

  **回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存**。

  - 内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫文件页。大部分文件页都可以直接释放内存，以后有需要时，再从磁盘重新读取。

  - 被应用程序修改过并且暂时还没写入磁盘的数据（脏页），要先写入磁盘才能进行内存释放。

- 匿名页（Anonymous Page）

  通过 Linux 的 **Swap 机制**，把不常访问的内存先写到磁盘中，然后释放这些内存，再次访问这些内存时，重新从磁盘读入。

  匿名页没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次访问，所以不能直接释放内存。




### 缺页中断

操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统会将数据以页的方式加载到内存中，上述过程被称为缺页中断。当操作系统发生缺页中断时，会通过系统调用将 page 读到内存中。

缺页中断处理：

- 如果有空闲的物理内存

  直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

- 如果没有空闲的物理内存

  内核开始进行回收内存的工作。

  - 后台内存回收 `kswapd`

    唤醒 `kswapd` 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。

    > `kSwapd` 是 Linux 负责页面置换的守护进程，也是负责交换闲置内存的主要进程。
    >
    > 在空闲内存低于一定水位时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。
    >
    > kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。

  - 直接内存回收（direct reclaim）

    如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

- 如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会触发 OOM（Out of Memory）机制。

  OOM机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。

#### 页面置换算法

页面置换算法的功能是出现缺页异常而内存已满时，选择被置换的物理页面算法。

常见的页面置换算法有如下几种：

- 最佳页面置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用的置换算法（LRU）
- 时钟页面置换算法（Lock）
- 最不常用置换算法（LFU）



### Swap 机制

Swap 机制指的是当物理内存不够用，内存管理单元（Memory Management Unit，MMU）提供调度算来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。

Swap 把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：

- 换出（Swap Out）

  是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。

- 换入（Swap In）

  是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。

如果没有空闲的物理内存，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement），替换操作又会触发 Swap 机制。



## Page Cache

应用程序读取文件的数据的时候，Linux 操作系统是会对读取的文件数据进行缓存的，会缓存在文件系统中的 Page Cache（下图中的页缓存）。

<img src="https://gitee.com/fushengshi/image/raw/master/image-20240504115230906.png" alt="image-20240504115230906" style="zoom: 80%;" />

### 预读机制

> 空间局部性原理。

#### 预读失效

提前加载进来的页，并没有被访问，就是预读失效。

使用传统的 LRU 算法，就会把预读页放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。

Linux 操作系统实现两个了 LRU 链表。

- 活跃 LRU 链表（active_list）

  活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页。

- 非活跃 LRU 链表（inactive_list）

  不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页。

预读页就只需要加入到 inactive_list 区域的头部，当页被真正访问的时候才将页插入 active_list 的头部。

> Linux 操作系统和 MySQL Innodb 通过改进传统 LRU 链表来避免预读失效带来的影响，具体的改进分别如下：
>
> - Linux 操作系统实现两个了 LRU 链表：
>
>   活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）。
>
> - MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：
>
>   young 区域 和 old 区域。
>
> 这两个改进方式，设计思想都是类似的，都是将数据分为了冷数据和热数据，然后分别进行 LRU 算法。



#### 缓存污染

在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到活跃 LRU 链表里，然后之前缓存在活跃 LRU 链表里的热点数据全部都被淘汰，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表就被污染了。

避免缓存污染带来的影响，在批量读取数据时候，如果这些大量数据只会被访问一次，不会进入到活跃 LRU 链表，也就不会把热点数据淘汰，只会在非活跃 LRU 链表中，后续很快会被淘汰。

> Linux 操作系统和 MySQL Innodb 存储引擎分别：
>
> - Linux 操作系统
>
>   在内存页被访问第二次的时候，将页从 inactive_list 升级到 active_list 里。
>
> - MySQL Innodb
>   
>   在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，还要进行停留在 old 区域的时间判断：
>   
>   - 如果第二次的访问时间与第一次访问的时间 在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域。
>   - 如果第二次的访问时间与第一次访问的时间 超过 1 秒，那么该页就会从 old 区域升级到 young 区域。



### 缓存一致性

一切内存缓存都存在一致性问题：内存中的数据与磁盘中的数据不一致。

- 写穿（Write Through）

  向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性。

- 写回（Write Back）

  Linux 默认的一致性方案。
  
  系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，依赖于以下三种系统调用：
  
  - **`fsync(fd)`**
  
    文件的脏数据和脏元数据全部刷新至磁盘中。
  
  - `fdatasync(fd)`
  
    文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息。
  
  - `sync()`
  
    对系统中所有的脏的文件数据元数据刷新至磁盘中。



# 附录

## 局部性原理

程序局部性原理表现为：时间局部性和空间局部性。

- 时间局部性

  如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行。

  如果某块数据被访问，则不久之后该数据可能再次被访问。

- 空间局部性

  一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。

无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。



## Java 内存

JVM 启动的时候会在用户态申请一块内存，申请的这块内存中有一部分会被称为堆，一般申请的对象会放在这个堆上，堆上的对象是受GC 管理的。

除了堆内的内存，其他的内存都被称为堆外内存。

- 在堆外内存中如果通过 Java 的 DirectByteBuffer 申请的，这块内存其实也是间接受 GC 管理的。
- JNI 直接调用 C 函数申请堆外内存，这块内存只能手动管理。



## 直接与非直接 I/O

Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是页缓存，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。

根据是否利用操作系统的缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O：

- 直接 I/O

  不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。

- 非直接 I/O

  读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

> 传输大文件的时候，使用异步 I/O + 直接 I/O。
>
> 传输小文件的时候，则使用零拷贝技术。



## 进程内存管理

在 Linux 内核中，进程和线程都是用 task_struct 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 task_struct 相比进程的 task_struct 承载的资源比较少。

### task_struct

进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了进程虚拟内存空间的全部信息。

```c
struct task_struct {
    // 进程id
    pid_t				pid;
    // 用于标识线程所属的进程 pid
    pid_t				tgid;
    // 进程打开的文件信息
    struct files_struct	*files;
    // 内存描述符表示进程虚拟地址空间
    struct mm_struct    *mm;

    ...
}
```



### mm_struct

内核中采用了一个叫做内存描述符的 mm_struct 结构体来表示进程虚拟内存空间的全部信息。

```c
struct mm_struct {
    unsigned long task_size;  /* size of task vm space */
    unsigned long start_code, end_code, start_data, end_data;
    unsigned long start_brk, brk, start_stack;
    unsigned long arg_start, arg_end, env_start, env_end;
    unsigned long mmap_base;  /* base of mmap area */
    unsigned long total_vm;   /* Total pages mapped */
    unsigned long locked_vm;  /* Pages that have PG_mlocked set */
    unsigned long pinned_vm;  /* Refcount permanently increased */
    unsigned long data_vm;    /* VM_WRITE & ~VM_SHARED & ~VM_STACK */
    unsigned long exec_vm;    /* VM_EXEC & ~VM_WRITE & ~VM_STACK */
    unsigned long stack_vm;   /* VM_STACK */

    struct vm_area_struct *mmap;

    struct rb_root mm_rb;

    ...
}
```

每个进程都有唯一的 mm_struct 结构体，每个进程的虚拟地址空间都是独立，互不干扰。

通过 `fork()` 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份**拷贝**，直接从父进程中拷贝到子进程中。

> 子进程共享了父进程的虚拟内存空间，这样子进程就变成线程，是否共享地址空间几乎是进程和线程之间的本质区别。
>
> Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程。

内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。



### vm_area_struct

结构体 vm_area_struct 描述了这些虚拟内存区域 VMA（virtual memory area）。

```c
struct vm_area_struct {
	unsigned long vm_start;		/* Our start address within vm_mm. */
	unsigned long vm_end;		/* The first byte after our end address within vm_mm. */
	/*
	 * Access permissions of this VMA.
	 */
	pgprot_t vm_page_prot;
	unsigned long vm_flags;	

	struct anon_vma *anon_vma;	/* Serialized by page_table_lock */
    struct file * vm_file;		/* File we map to (can be NULL). */
	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE units */	
	void * vm_private_data;		/* was vm_pte (shared mem) */
	/* Function pointers to deal with this struct. */
	const struct vm_operations_struct *vm_ops;
}
```

所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找。

每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。

而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 mm_rb 中。

![image.png](https://gitee.com/fushengshi/image/raw/master/d945d22667c4ea56dbd2f19677306a91-20230309234037651.png)











