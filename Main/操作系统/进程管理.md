# 进程管理

编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，这个运行中的程序称为进程（Process）。

在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。

- 运行状态（Running）：该时刻进程占用 CPU。
- 就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行。
- 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时即使给它 CPU 控制权，它也无法运行。



# 进程

进程是操作系统进行资源分配的基本单位，每个进程都有自己的独立内存空间。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

## 进程控制块

在操作系统中用进程控制块（process control block，PCB）数据结构描述进程。

**PCB 是进程存在的唯一标识**，一个进程的存在，必然会有一个 PCB，如果进程消失 PCB 也随之消失。

PCB 具体包含信息：

- 进程描述信息：

  进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符。

  用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。

- 进程控制和管理信息：

  进程当前状态，如 new、ready、running、waiting 或 blocked 等。

  进程优先级：进程抢占 CPU 时的优先级。

- 资源分配清单：

  有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

- CPU 相关信息：

  CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



## 进程的控制

PCB 通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列：

- 就绪队列

  将所有处于就绪状态的进程链在一起。

- 阻塞队列

  把所有因等待某事件而处于等待状态的进程链在一起。

进程的创建、终止、阻塞、唤醒的过程，这些过程就是进程的控制。

### 阻塞进程

当进程需要等待某一事件完成时，可以调用阻塞语句阻塞等待。一旦被阻塞等待只能由另一个进程唤醒。

阻塞进程的过程如下：

- 找到将要被阻塞进程标识号对应的 PCB。
- 如果该进程为运行状态则保护其现场，将状态转为阻塞状态，停止运行。
- 将该 PCB 插入到阻塞队列中去。

### 唤醒进程

进程由运行转变为阻塞状态是由于进程必须等待某一事件的完成，处于阻塞状态的进程不可能叫醒自己。如果某进程正在等待 I/O 事件，只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句唤醒。

唤醒进程的过程如下：

- 在该事件的阻塞队列中找到相应进程的 PCB。
- 将其从阻塞队列中移出，并置其状态为就绪状态。
- 把该 PCB 插入到就绪队列中，等待调度程序调度。



## 进程上下文切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行。一个进程切换到另一个进程运行称为进程的上下文切换。

> 对比 CPU 上下文切换。

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

- 虚拟内存、栈、全局变量等**用户空间资源**切换。
- 内核堆栈、寄存器等**内核空间资源**切换。

发生进程上下文切换场景：

- 时间片

  为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。

  当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行。

- 资源不足

  进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

- `sleep` 函数

  当进程通过 `sleep` 函数这样的方法将自己主动挂起时也会重新调度。

- 高优先级进程

  当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。

- 硬件中断

  发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。



## 进程通信

- 匿名管道

  匿名管道是特殊文件只存在于内存，shell 命令中的 `|` 竖线就是匿名管道。

  - 通信的数据是无格式的流并且大小受限。
  - 通信的方式是单向的。

  - 匿名管道是只能用于父子关系的进程间通信。
  - 匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

- 命名管道

  - 在文件系统创建一个类型为 `p` 的设备文件，无关系的进程可以通过这个设备文件进行通信。

  > 匿名管道和命名管道，进程写入的数据都缓存在内核中，另一个进程读取数据时从内核中获取。
  >
  > 通信数据都遵循先进先出原则，不支持 `lseek` 之类的文件定位操作。

- 消息队列

  克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的消息链表，消息队列的消息体是可以用户自定义的数据类型。每次数据的写入和读取都要经过用户态与内核态之间的拷贝过程。

  - 发送数据时，会分成独立的消息体。
  - 接收数据时，也要与发送方发送的消息体的数据类型保持一致，保证读取的数据是正确的。

- 共享内存

  直接分配一个共享空间，每个进程都可以直接访问，不需要陷入内核态或者系统调用，提高了通信的速度。

  多进程竞争同个共享资源会造成数据的错乱。

- 信号量

  互斥访问，保护共享资源，确保任何时刻只有一个进程访问共享资源。

  信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制。

- 信号

  信号是异步通信机制。

  信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生的系统事件。

  信号事件的来源主要有硬件来源（如键盘 `Cltr+C`）和软件来源（如 `kill` 命令）。

- Socket

  Socket 不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信。

  可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。



## 进程调度

进程调度算法也称 CPU 调度算法。当 CPU 空闲时，操作系统就选择内存中的某个就绪状态的进程分配 CPU。

常见的调度算法：

- 先来先服务调度算法（First Come First Severed，FCFS）

  每次从就绪队列选择最先进入队列的进程，然后一直运行直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

- 最短作业优先调度算法（Shortest Job First，SJF）

  优先选择运行时间最短的进程来运行，有助于提高系统的吞吐量。

- 高响应比优先调度算法（Highest Response Ratio Next，HRRN）

  权衡了短作业和长作业，每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行。

- 时间片轮转调度算法（Round Robin，RR）

  每个进程被分配一个时间片（Quantum），允许该进程在该时间段中运行。

- 最高优先级调度算法（Highest Priority First，HPF）

  从就绪队列中选择最高优先级的进程进行运行。

- 多级反馈队列调度算法（Multilevel Feedback Queue）

  时间片轮转算法和最高优先级算法的综合和发展。



# 线程

线程又叫做轻量级进程，是进程的一个实体，是处理器任务调度和执行的基本单位位。线程只拥有在运行中必不可少的资源（如程序计数器，一组寄存器和栈），可与同属一个进程的其他的线程共享进程所拥有的全部资源。

> 线程是调度的基本单位，而进程则是资源拥有的基本单位。

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。

> 是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已。



## 线程上下文切换

操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。

- 当两个线程不属于同一个进程

  切换过程和进程上下文切换相同。

- 当两个线程属于同一个进程

  因为虚拟内存是共享的，所以在切换时虚拟内存这些资源保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。



## 线程的实现

主要有三种线程的实现方式：

- 用户线程（User Thread）：在用户空间实现的线程，不由内核管理，由用户态的线程库完成线程的管理。
- 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程。
- 轻量级进程（Light Weight Process）：在内核中来支持用户线程。

> Java 线程模型见附录。

### 用户线程

用户线程基于用户态的线程管理库实现，线程控制块（Thread Control Block，TCB） 在线程库里面实现，操作系统看不到 TCB，只能看到整个进程的 PCB。

用户线程的整个线程管理和调度，操作系统不直接参与，由用户级线程库函数完成线程的管理，包括线程的创建、终止、同步和调度等。

用户级线程的模型，类似多对一的关系，即多个用户线程对应同一个内核线程。

### 内核线程

内核线程由操作系统管理，线程对应的 TCB 放在操作系统里，线程的创建、终止和管理都是由操作系统负责。

内核线程的模型，类似一对一的关系，即一个用户线程对应一个内核线程。

> 内核线程和用户态线程的区别：
>
> 内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度不涉及地址空间切换。



## 进程和线程比较

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位。

- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈。

- 线程能减少并发执行的时间和空间开销。

  - 线程的创建时间快

    - 进程在创建的过程中，需要资源管理信息，比如内存管理信息、文件管理信息。
    - 线程在创建的过程中，不会涉及资源管理信息，而是共享。

  - 线程的终止时间快

    线程释放的资源相比进程少。

  - 线程切换快

    同一个进程内的线程具有相同的地址空间（虚拟内存共享）。

    - 同一个进程的线程都具有同一个页表，切换不需要切换页表。
    - 进程间切换要切换页表，页表的切换过程开销是比较大的。

  - 线程数据交互效率高

    由于同一进程的各线程间共享内存和文件资源，在线程之间数据传递不需要经过内核，线程之间的数据交互效率更高。



# 附录

## 用户态 / 内核态

在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，系统崩溃的概率将大大增加。CPU 将指令分为特权指令和非特权指令，对于危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用不会造成危险的指令。

很多程序运行于用户态，但在执行的过程中一些操作要在内核权限下才能执行，涉及到从用户态切换到内核态的过程。

- 系统调用

  操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。

  比如 C 函数库中的内存分配函数 `malloc()`，它具体是使用 `sbrk()` 系统调用来分配内存， 当 `malloc` 调用 `sbrk()` 的时候就涉及一次从用户态到内核态的切换。

  > 系统调用的本质也是中断，相对于外围设备的硬中断，这种中断称为软中断。

- 异常事件

  当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这时就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，如缺页异常。

- 外围设备的中断

  当外围设备完成用户的请求操作后，会向 CPU 发出中断信号，CPU 会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，就发生从用户态到内核态的转换。



## Java 线程模型

Java 线程 API 通常采用宿主系统的线程库来实现。在 UNIX 类系统上，采用 Pthread 来实现。

在 Windows 和 Linux 等主流操作系统中，**Java 线程采用一对一线程模型**，一个 Java 线程对应一个系统内核线程。

Linux下，Java 的线程对象的 `start()` 方法调用了一个 native 的 `start0()` 方法，调用 `pthread_create` 方法创建一个 OS 内核级线程，并为该线程分配栈资源。

> 这个栈资源对于 JVM 是堆外内存，因此堆外内存的大小会影响 JVM 可创建的线程数。



### 用户栈 / 内核栈

在 JVM 概念中，JVM 栈执行 Java 方法，本地方法栈执行 native 方法。

JVM 只是在概念上区分了这两种栈，在 HotSpot 中，将 JVM 栈与本地方法栈二合一，Java 方法与 native 方法都在同一个用户栈中调用，发生系统调用时，再切换到内核栈运行。

- 用户栈

  应用程序直接使用的栈，位于应用程序的用户进程空间，用来存储局部、临时变量、函数调用。

- 内核栈

  存放在内核空间，如系统调用在陷入内核后，系统调用中也存在函数调用和自动变量，这些都要内核栈支持。

  - 当进程运行在用户态时，CPU 堆栈指针寄存器指向的是用户堆栈地址，使用的是用户堆栈。
  - 当进程运行在内核态时，CPU 堆栈指针寄存器指向的是内核堆栈地址，使用的是内核堆栈。



## 协程

协程，又称微线程，是一种用户态的轻量级线程，协程的调度完全由用户控制（也就是在用户态执行）。

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

协程并不是取代线程，而且抽象于线程之上。线程是被分割的CPU资源，协程是组织好的代码流程，协程需要线程来承载运行。








