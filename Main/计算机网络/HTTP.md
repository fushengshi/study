# HTTP

HTTP 是超文本传输协议，也就是 HyperText Transfer Protocol。



## HTTPS

HTTP 与 HTTPS 区别：

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



HTTPS 采用的是对称加密和非对称加密结合的混合加密方式：

- 在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据。

采用混合加密的方式的原因：

- 对称加密

  只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。

- 非对称加密

  使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。



### SSL/TLS 协议

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产会话秘钥。
- 双方采用会话秘钥进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

TLS 的握手阶段涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法和 ECDHE 算法。

#### TLS 1.3 协议

默认使用 ECDHE 作为密钥协商算法。

该版本协议允许客户端无需等待 TLS 握手完成就开始发送应用程序数据的操作，在首次连接的时候，即第三次握手时，就已经开始发送实际的业务数据了，而第一次握手和第二次握手正好花费了 1 RTT 时间，所以，首次连接的成本是 1 RTT。



### 数字证书和 CA 机构

一个数字证书通常包含了：

- 公钥。
- 持有者信息。
- 证书认证机构（CA）的信息。
- CA 对这份文件的数字签名及使用的算法。
- 证书有效期。
- 还有一些其他额外信息。

为了让服务端的公钥被大家信任，服务端的证书都是由 CA（Certificate Authority，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。

CA 签发证书的过程：

- 首先 CA 会把服务端公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值。
- 然后 CA 会使用 **CA 的私钥** 将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名。
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书。

客户端校验服务端的数字证书的过程：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1。
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 **CA 的公钥解密** Certificate Signature 内容，得到一个 Hash 值 H2 。
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。



### RSA 握手

#### RSA 握手过程

- 第一次握手

  客户端首先会发一个 `Client Hello` 消息。

  消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。

- 第二次握手

  当服务端收到客户端的消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）。

  接着，返回 `Server Hello` 消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。

  服务端为了证明自己的身份，会发送 `Server Certificate` 给客户端，这个消息里含有数字证书。

- 第三次握手

  客户端验证完证书后，得到**服务端证书中公钥**。

  接着，客户端就会生成一个新的随机数（pre-master），用服务器的 RSA 公钥加密该随机数，通过 `Client Key Exchange` 消息传给服务端。

  > 服务端收到后，用**服务端证书中私钥**解密，客户端发的随机数（pre-master）。
  >
  > 至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

  生成完会话密钥后，客户端发一个 `Change Cipher Spec`，告诉服务端开始使用加密方式发送消息。

  然后，客户端再发一个 `Encrypted Handshake Message` 消息，把之前所有发送的数据做个摘要，再用会话密钥加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

- 第四次握手

  服务器也是同样的操作，发 `Change Cipher Spec` 和 `Encrypted Handshake Message` 消息，如果双方都验证加密和解密没问题，那么握手正式完成。

  最后，就用会话密钥加解密 HTTP 请求和响应了。

> 使用 RSA 密钥协商算法的最大问题是不支持前向保密。
>
> 因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。
>



### ECDHE 握手

#### DH 算法

小红和小明各自生成一个随机整数作为私钥，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称

现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出公钥：

- 小红的公钥记作 A，`A = G ^ a ( mod P )`。
- 小明的公钥记作 B，`B = G ^ b ( mod P )`。

A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的。

双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。

- 小红执行运算：`K = B ^ a ( mod P )`。
- 小明执行运算：`K = A ^ b ( mod P )`。

这个 K 就是小红和小明之间用的对称加密密钥，可以作为会话密钥使用。

#### DHE 算法

根据私钥生成的方式，DH 算法分为两种实现：

- ~~static DH 算法~~（废弃）

  static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。

  static DH 算法不具备前向安全性，黑客破解出服务器的私钥计算出会话密钥，之前截获的加密数据会被破解。

- DHE 算法

  DHE 算法，E 全称是 ephemeral（临时性的），双方的私钥在每次密钥交换通信时，都是随机生成的、临时的。

#### ECDHE 算法

ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。



#### ECDHE 握手过程

- 第一次握手

  客户端首先会发一个 `Client Hello` 消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random）。

- 第二次握手

  服务端收到客户端消息后，会返回 `Server Hello` 消息，消息面有服务器确认的 TLS 版本号，也给出了一个随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。

  服务端为了证明自己的身份，发送 `Certificate` 消息，会把证书也发给客户端。

  因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送 `Server Key Exchange` 消息。

  - 生成随机数作为服务端椭圆曲线的私钥，保留到本地。
  - 选择了椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，公开给客户端。
  - 根据基点 G 和私钥计算出**服务端的椭圆曲线公钥**，公开给客户端。

- 第三次握手

  客户端验证完证书后，得到服务端证书中公钥。

  - 生成一个随机数作为客户端椭圆曲线的私钥，保留到本地。
  - 再根据服务端前面给的椭圆曲线基点 G，计算出**客户端的椭圆曲线公钥**。

  > 客户端将自身的椭圆曲线公钥使用服务器RSA公钥加密后，通过 `Client Key Exchange` 消息发给服务器。
  >
  > 对于 ECDH + anon 这样的密钥协商算法组合，**不需要依赖服务端证书中公钥**，而是通过 `Server Key Exchange` 消息协商出密钥。

  计算出会话密钥后，客户端会发一个 `Change Cipher Spec` 消息，告诉服务端后续改用对称算法加密通信。

  客户端会发 `Encrypted Handshake Message` 消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。

  最终的会话密钥，就是用 客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥）三个材料生成的。

- 第四次握手

  服务器也是同样的操作，发 `Change Cipher Spec` 和 `Encrypted Handshake Message` 消息，如果双方都验证加密和解密没问题，那么握手正式完成。

  最后，就用会话密钥加解密 HTTP 请求和响应了。



## HTTP/2

- 头部压缩

  - 对于常见的 HTTP 头部通过**静态表和 Huffman 编码**的方式，将体积压缩了近一半。

  - 针对后续的请求头部，还可以建立**动态表**，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。

    动态表并非可以无限增大，因为动态表是会占用内存的，动态表越大内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。

- Stream 并发

  ![image-20240707202707113](https://gitee.com/fushengshi/image/raw/master/image-20240707202707113.png)

  多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧 1 -> B 请求帧 1 -> A 请求帧 2 -> B 请求帧 2，但是同一个 Stream 里的帧必须严格有序。

  可以根据资源的渲染顺序来设置 Stream 的优先级，从而提高用户体验。

  > HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题。
  >
  > 但是 HTTP/2 还是存在**队头阻塞**的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。
  >
  > HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么前 1 个字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

- 服务器支持主动推送资源

  大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。



HTTP/2 的连接需要 3 RTT（TCP 握手 1 RTT + TLS 握手 2 RTT），

如果 TLS 升级到 1.3，那么 HTTP/2 连接需要 2 RTT（TCP 握手 1 RTT + TLS 握手 1 RTT），考虑会话复用则需要 1 RTT。

> TLS 1.3 第三次握手时，就已经开始发送实际的业务数据。



## HTTP/3

### QUIC 协议

HTTP/3 不只是简单将传输协议替换成了 UDP，还基于 UDP 协议在应用层实现了 QUIC 协议（Quick UDP Internet Connections，快速 UDP 网络连接），它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成**可靠**的了，所以不用担心数据包丢失的问题。

QUIC 协议的优点：

- 无队头阻塞

  QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，可以在同一条连接上并发传输多个 Stream，Stream 可以认为一条 HTTP 请求。

  QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。

  > TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留。

- 更快的连接建立

  HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT（Round-Trip Time 往返时延），握手的目的是为确认双方的连接 ID，连接迁移就是基于连接 ID 实现的。

  HTTP/3 的 **QUIC 协议并不与 TLS 分层**，QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的记录 ，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 RTT 就可以同时完成建立连接与密钥协商，第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0 RTT 的效果。

  > 对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、OpenSSL 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

  <img src="https://gitee.com/fushengshi/image/raw/master/image-20240504235229460.png" alt="image-20240504235229460" style="zoom: 50%;" />

- 连接迁移

  QUIC 协议没有用四元组的方式绑定连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以复用原连接，消除重连的成本，达到连接迁移的功能。

  > 基于 TCP 传输协议的 HTTP 协议，通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。



## 附录

### 网络模型

![image-20240504205907659](https://gitee.com/fushengshi/image/raw/master/image-20240504205907659.png)

![image-20240616215043872](https://gitee.com/fushengshi/image/raw/master/image-20240616215043872.png)

TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：

#### 应用层

负责向用户提供一组应用程序。

- HTTP（Hypertext Transfer Protocol，超文本传输协议）

  基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

- SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）

  基于 TCP 协议，是一种用于发送电子邮件的协议。

  SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。

- POP3/IMAP（邮件接收协议）

  基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。

  IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。

- FTP（File Transfer Protocol，文件传输协议）

  基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。

  FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。

- Telnet（远程登陆协议）

  基于 TCP 协议，用于通过一个终端登陆到其他服务器。

  Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。

- SSH（Secure Shell Protocol，安全的网络传输协议）

  基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。

- RTP（Real-time Transport Protocol，实时传输协议）

  通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。

- DNS（Domain Name System，域名管理系统）

  基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

#### 传输层

负责端到端的通信。

- TCP（Transmission Control Protocol，传输控制协议 ）

  提供面向连接的，可靠的数据传输服务。

- UDP（User Datagram Protocol，用户数据协议）

  提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），简单高效。

#### 网络层

负责网络包的封装、分片、路由、转发。

- IP（Internet Protocol，网际协议）

  TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

  目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

- ARP（Address Resolution Protocol，地址解析协议）

  ARP 协议解决的是网络层地址和链路层地址之间的转换问题。

  因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。

- ICMP（Internet Control Message Protocol，互联网控制报文协议）

  一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。

- NAT（Network Address Translation，网络地址转换协议）

  NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。

- OSPF（Open Shortest Path First，开放式最短路径优先）

  一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。

- RIP（Routing Information Protocol，路由信息协议）

  一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。

- BGP（Border Gateway Protocol，边界网关协议）

  一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。

#### 网络接口层

负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等。



### Linux 网络协议栈

![image-20240504205801737](https://gitee.com/fushengshi/image/raw/master/image-20240504205801737.png)

- 应用程序需要通过系统调用，来跟 Socket 层进行数据交互。
- Socket 层的下面就是传输层、网络层和网络接口层。
- 最下面的一层，则是网卡驱动程序和硬件网卡设备。



### RPC

RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。

虽然大部分 RPC 协议底层使用 TCP，但实际上它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。

RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。

- 服务发现

  首先要向某个服务器发起请求，先建立连接，而建立连接的前提是知道 **IP 地址和端口**。这个找到服务对应的 IP 端口的过程，其实就是服务发现。

  在 HTTP 中，知道服务的域名可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。

  RPC 一般会有专门的中间服务去保存服务名和 IP 信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 CoreDNS。

- 底层连接形式

  而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个**连接池**，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来。

- 传输的内容

  RPC 因为定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据。



### WebSocket

WebSocket 完美继承了 TCP 协议的全双工能力，并且提供了解决粘包的方案。

它适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。

> 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用定时轮询或者长轮询的方式实现服务器推送（comet）的效果。



### 响应码

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |


