# TCP

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

- 面向连接

  一对一才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息。

- 可靠的

  无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端。

- 字节流

  用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，如果接收方的程序如果不知道消息的边界，无法读出一个有效的用户消息。
  
  TCP 报文是有序的，当前一个TCP 报文没有收到的时候，即使先收到了后面的 TCP 报文，也不能给应用层处理。
  
  > 队首阻塞。
  
  不能认为一个用户消息对应一个 TCP 报文，所以 TCP 是面向字节流的协议。

建立一个 TCP 连接是需要客户端与服务端达成三个信息的共识：

- Socket：由 IP 地址和端口号组成。
- 序列号：用来解决乱序问题等。
- 窗口大小：用来做流量控制。



## TCP 三次握手

<img src="https://gitee.com/fushengshi/image/raw/master/image-20240529231234030.png" alt="image-20240529231234030" style="zoom: 50%;" />

三次握手过程：

- 客户端和服务端都处于 CLOSE 状态。

  先是服务端主动监听某个端口，处于 LISTEN 状态。

- 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的序号字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。

  把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

- 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的序号字段中，其次把 TCP 首部的确认应答号字段填入 `client_isn + 1`，接着把 SYN 和 ACK 标志位置为 1。

  把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

- 客户端收到服务端报文后，要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次确认应答号字段填入 `server_isn + 1` 。

  把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。

- 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。

为什么是三次握手：

- 三次握手才能保证双方具有接收和发送的能力。

- 三次握手才可以阻止重复历史连接的初始化。

  在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。

- 三次握手才可以同步双方的初始序列号。

- 三次握手才可以避免资源浪费。

> 客户端 `connect()` 成功返回是在第二次握手，服务端 `accept()` 成功返回是在三次握手成功之后。



## TCP 四次挥手

<img src="https://gitee.com/fushengshi/image/raw/master/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

四次挥手过程：

- 客户端打算关闭连接，会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，即 FIN 报文，客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，向客户端发送 ACK 应答报文，服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 ACK 应答报文后，客户端进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，向客户端发送 FIN 报文，服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，客户端进入 `TIME_WAIT` 状态
- 服务端收到了 ACK 应答报文后，进入 `CLOSE` 状态，服务端完成连接的关闭。
- 客户端在经过 2MSL 时间后，自动进入 `CLOSE` 状态，客户端完成连接的关闭。



`TIME_WAIT` 等待的 2MSL 时间？

> MSL（Maximum Segment Lifetime 报文最大生存时间），是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

- 2MSL 时长相当于**至少允许报文丢失一次**。若 ACK 在一个 MSL 内丢失，被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。

- 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 `TIME-WAIT` 时间内客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，2MSL 时间重新计时。



TIME-WAIT 状态原因：

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收。
- 保证被动关闭连接的一方，能被正确的关闭。



>  TCP 服务端的流程：
>
> 1. 创建服务端 Socket，`bind()` 绑定端口、`listen()` 监听端口。
> 2. 将服务端 Socket 注册到 epoll。
> 3. `epoll_wait` 等待连接到来，连接到来时调用 `accept()` 获取已连接的 Socket。
> 4. 将已连接的 Socket 注册到 epoll。
> 5. `epoll_wait` 等待事件发生。
> 6. 对方连接关闭时，我方调用 `close()`。



## 重传机制

### 超时重传

重传机制的其中一个方式是在发送数据时设定一个定时器，当超过指定的时间没有收到对方的 ACK 确认应答报文重发该数据，也就是超时重传。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

超时重传时间以 RTO（Retransmission Timeout 超时重传时间）表示，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。

### 快速重传

TCP 还有另外一种快速重传（Fast Retransmit）机制，不以时间为驱动，而是以数据驱动重传。

快速重传的工作方式是当收到三个相同的 ACK 报文时，在定时器过期之前重传丢失的报文段。

### SACK 方法

一种实现重传机制的方式：SACK（ Selective Acknowledgment），选择性确认。

这种方式需要在 TCP 头部选项字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给发送方，发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息就可以只重传丢失的数据。

### Duplicate SACK

Duplicate SACK 又称 D-SACK，主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。



## 流量控制

流量控制是 TCP 提供一种机制，让发送方根据接收方的实际接收能力控制发送的数据量。

发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，操作系统的缓冲区可以被操作系统调整。

### 滑动窗口

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。



## 拥塞控制

拥塞控制的目的是避免发送方的数据填满整个网络。

拥塞窗口 cwnd：发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

### 慢启动

慢启动的算法规则：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

慢启动算法，发包的个数是**指数性的增长**。

### 拥塞避免

当拥塞窗口 cwnd 超过慢启动门限 ssthresh 就会进入拥塞避免算法。

拥塞避免算法规则：每当收到一个 ACK 时，cwnd 增加 `1/cwnd`。

拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

### 拥塞发生

当网络出现拥塞会发生数据包重传，重传机制主要有两种：

- 超时重传

  ssthresh 设为 `cwnd/2`，cwnd 重置为 1 （恢复为 cwnd 初始化值，这里假定 cwnd 初始化值 1），重新开始慢启动。

- 快速重传

  收到 3 个重复 ACK。
  
  快速重传和快速恢复算法一般同时使用。

### 快速恢复

快速恢复算法认为能收到 3 个重复 ACK 说明网络没有那么糟糕。

快速恢复算法如下：

- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）。
- 重传丢失的数据包。
- 如果再收到重复的 ACK，那么 cwnd 增加 1。
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，即再次进入拥塞避免状态。

<img src="https://gitee.com/fushengshi/image/raw/master/image-20240529231331425.png" alt="image-20240529231331425" style="zoom: 80%;" />



# UDP

UDP（User Datagram Protocol，用户数据协议），提供**无连接**的，**尽最大努力**的数据传输服务（不保证数据传输的可靠性），简单高效。

TCP 和 UDP 区别：

- 连接
  - TCP 是面向连接的传输层协议，传输数据前先要建立连接。
  - UDP 是不需要连接，即刻传输数据。

- 服务对象
  - TCP 是一对一的两点服务，即一条连接只有两个端点。
  - UDP 支持一对一、一对多、多对多的交互通信。

- 可靠性

  - TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。

  - UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现可靠的传输协议，比如 QUIC 协议。

    > 详见 HTTP/3 QUIC 协议。

- 拥塞控制、流量控制
  - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
  - UDP 则没有，即使网络非常拥堵也不会影响 UDP 的发送速率。

- 首部开销
  - TCP 首部长度较长，有一定的开销，首部在没有使用选项字段时是 20 个字节，使用了选项字段会更长。
  - UDP 首部只有 8 个字节，是固定不变的，开销较小。

- 传输方式
  - TCP 是流式传输，没有边界，但保证顺序和可靠。
  - UDP 是一个包一个包的发送，是有边界的，可能会丢包和乱序。

- 分片不同

  - TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，

    如果中途丢失了一个分片，只需要传输丢失的这个分片。

  - UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。



TCP 和 UDP 应用场景：

- TCP 是面向连接，能保证数据的可靠性交付，经常用于：

  - FTP 文件传输。
  - HTTP / HTTPS。

- UDP 面向无连接，可以随时发送数据，再加上 UDP 本身的处理既简单又高效，经常用于：

  - 包总量较少的通信，如 DNS 、SNMP 等。
  - 视频、音频等多媒体通信。
  - 广播通信。



# IP

TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便可以跨网络传播并到达正确的目的地。

目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。

> IP 的作用是主机之间通信用的，而 MAC 的作用则是实现直连的两个设备之间通信，而 IP 则负责在没有直连的两个网络之间进行通信传输。
>



# 附录

## TCP 序列号和确认号

- 公式一：序列号 = 上一次发送的序列号 + len（数据长度）。

  特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。

- 公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。

  特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。

<img src="https://gitee.com/fushengshi/image/raw/master/ae18cbf6071c47b98014a68d05c37d16.png" alt="在这里插入图片描述" style="zoom:50%;" />